(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global = global || self, global.reactGeojson = factory(global.React));
}(this, (function (React) {
  var React__default = 'default' in React ? React['default'] : React;

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function ReactGeoJSON(_ref) {
    var apiKey = _ref.apiKey,
        _ref$center = _ref.center,
        center = _ref$center === void 0 ? {
      lat: 0.0,
      lng: 0.0
    } : _ref$center,
        _ref$onMapInitiated = _ref.onMapInitiated,
        onMapInitiated = _ref$onMapInitiated === void 0 ? function () {} : _ref$onMapInitiated,
        _ref$zoom = _ref.zoom,
        zoom = _ref$zoom === void 0 ? 10 : _ref$zoom,
        _ref$existingArea = _ref.existingArea,
        existingArea = _ref$existingArea === void 0 ? null : _ref$existingArea,
        _ref$areaStyles = _ref.areaStyles,
        areaStyles = _ref$areaStyles === void 0 ? {} : _ref$areaStyles,
        _ref$onSave = _ref.onSave,
        onSave = _ref$onSave === void 0 ? function () {} : _ref$onSave,
        _ref$mapStyles = _ref.mapStyles,
        mapStyles = _ref$mapStyles === void 0 ? [] : _ref$mapStyles,
        _ref$editable = _ref.editable,
        editable = _ref$editable === void 0 ? true : _ref$editable,
        _ref$children = _ref.children,
        children = _ref$children === void 0 ? function () {} : _ref$children,
        _ref$onPolygonsDrawn = _ref.onPolygonsDrawn,
        onPolygonsDrawn = _ref$onPolygonsDrawn === void 0 ? function () {} : _ref$onPolygonsDrawn,
        _ref$mapOptions = _ref.mapOptions,
        mapOptions = _ref$mapOptions === void 0 ? {} : _ref$mapOptions,
        _ref$scriptLibraries = _ref.scriptLibraries,
        scriptLibraries = _ref$scriptLibraries === void 0 ? null : _ref$scriptLibraries;

    var _useState = React.useState(false),
        map = _useState[0],
        setMap = _useState[1];

    var mapRef = React.useRef(null);
    var polygons = React.useRef([]);
    var zoomLevel = React.useRef(zoom);
    var centerPoint = React.useRef(center);
    var activePolygon = React.useRef(null);
    var listenersEnabled = React.useRef(false);
    var selectedPolygon = React.useRef(null);
    var polygonBeingAdded = React.useRef(null);
    var selectedInfoWindow = React.useRef(null);

    var _useState2 = React.useState(false),
        polygonSelected = _useState2[0],
        setPolygonSelected = _useState2[1];

    var activeDrawingSet = React.useRef([]);

    var _useState3 = React.useState([]),
        activeDrawing = _useState3[0],
        setActiveDrawing = _useState3[1];

    var identifier = React.useRef(Math.random().toString(36).substring(4));

    function mapInitiated() {
      var map = new google.maps.Map(mapRef.current, _extends(_extends({}, mapOptions), {}, {
        center: center,
        zoom: zoom,
        disableDefaultUI: true,
        clickableIcons: false,
        styles: mapStyles
      }));
      map.addListener('click', onMapClick);
      setMap(map);
      if (typeof onMapInitiated === 'function') onMapInitiated(map);
    }

    function onMapClick() {
      if (polygonBeingAdded.current === null) {
        deselect();
      }
    }

    React.useEffect(function () {
      if (map && center.lat !== centerPoint.current.lat && center.lng !== centerPoint.current.lng) {
        map.panTo(center);
        centerPoint.current = center;
      }
    }, [center]);
    React.useEffect(function () {
      if (map) {
        map.setOptions({
          styles: mapStyles
        });
      }
    }, [mapStyles]);
    React.useEffect(function () {
      if (map && zoom !== zoomLevel.current) {
        map.setZoom(zoom);
        zoomLevel.current = zoom;
      }
    }, [zoom]);
    var drawPolygon = React.useCallback(function (coords, name) {
      if (name === void 0) {
        name = null;
      }

      if (map === false) return;
      var polygon = new google.maps.Polygon(_extends({
        paths: coords,
        editable: false
      }, areaStyles));
      polygon.setMap(map);
      polygons.current.push(polygon);
      var center = null;
      var infoWindow = null;

      if (name) {
        center = {
          lat: 0,
          lng: 0
        };
        coords.forEach(function (coord) {
          center.lat += coord.lat;
          center.lng += coord.lng;
        });
        center.lat = center.lat / coords.length;
        center.lng = center.lng / coords.length;
        infoWindow = new google.maps.InfoWindow({
          content: name
        });
      }

      if (editable) {
        polygon.addListener('click', function () {
          return onPolygonClick(polygon, {
            infoWindow: infoWindow,
            center: center
          });
        });
      }
    }, [map]);

    function deselect() {
      setPolygonSelected(false);

      if (selectedPolygon.current !== null) {
        selectedPolygon.current.setEditable(false);
      }

      if (selectedInfoWindow.current !== null) {
        selectedInfoWindow.current.close();
      }

      if (polygonBeingAdded.current !== null) {
        polygonBeingAdded.current.setEditable(false);
      }
    }

    function onPolygonClick(polygon, opts) {
      if (editable === false) return;
      deselect();
      setPolygonSelected(true);
      polygon.setEditable(true);
      selectedPolygon.current = polygon;
      selectedInfoWindow.current = null;

      if (opts.infoWindow && opts.center) {
        selectedInfoWindow.current = opts.infoWindow;
        opts.infoWindow.setPosition(opts.center);
        opts.infoWindow.open(map);
      }
    }

    function getCoordsFromFeature(feature) {
      return feature.geometry.coordinates.map(function (c) {
        if (typeof c.lat !== 'undefined') return c;
        if (c.length === 2) return {
          lat: c[1],
          lng: c[0]
        };
        return c && c.map(function (latLng) {
          if (Array.isArray(latLng)) return {
            lat: latLng[1],
            lng: latLng[0]
          };
          return {
            lat: latLng.lat,
            lng: latLng.lng
          };
        });
      }).flat(2);
    }

    React.useEffect(function () {
      if (map === false) return;

      if (existingArea === null || typeof existingArea.features === 'undefined') {
        return;
      }

      clearAllPolygons();
      polygons.current = [];
      existingArea.features.forEach(function (feature) {
        var coords = getCoordsFromFeature(feature);
        drawPolygon(coords, feature.properties.Name);
      });
      if (typeof onPolygonsDrawn === 'function') onPolygonsDrawn(polygons.current);
    }, [map, existingArea]);

    function addNewPoint(e) {
      activeDrawingSet.current.push({
        lat: e.latLng.lat(),
        lng: e.latLng.lng()
      });
      activePolygon.current.setPath(activeDrawingSet.current);
      setActiveDrawing([].concat(activeDrawingSet.current));
    }

    function removeLastPoint(e) {
      activeDrawingSet.current.pop();
      activePolygon.current.setPath(activeDrawingSet.current);
      setActiveDrawing([].concat(activeDrawingSet.current));
    }

    function undo(e) {
      if (e.which === 90 && (e.ctrlKey || e.metaKey)) {
        removeLastPoint();
      }
    }

    var addListeners = React.useCallback(function () {
      listenersEnabled.current = true;
      map.addListener('click', addNewPoint);
      document.addEventListener('keydown', undo);
    }, [map]);
    React.useEffect(function () {
      if (document.querySelector('#react-geojson') !== null) return;
      var script = document.createElement('script');
      script.id = 'react-geojson';
      script.src = "https://maps.googleapis.com/maps/api/js?key=" + apiKey + "&callback=ReactGeoJSONInit" + identifier.current + (scriptLibraries !== null ? '&libraries=' + scriptLibraries : '');
      script.defer = true;
      script.async = true;
      window["ReactGeoJSONInit" + identifier.current] = mapInitiated;
      document.head.appendChild(script);
    }, []);

    function startEditing() {
      deselect();
      activeDrawingSet.current = [];
      setActiveDrawing([]);
      activePolygon.current = new google.maps.Polygon(_extends({
        editable: true
      }, areaStyles));
      activePolygon.current.addListener('click', function () {
        return onPolygonClick(activePolygon.current);
      });
      activePolygon.current.setMap(map);
      polygons.current.push(activePolygon.current);
      polygonBeingAdded.current = activePolygon.current;
      setPolygonSelected(true);

      if (listenersEnabled.current === false) {
        addListeners();
      }
    }

    function clearAllPolygons() {
      for (var i = 0; i < polygons.current.length; i++) {
        if (polygons.current[i]) polygons.current[i].setMap(null);
      }
    }

    function removeSelectedPolygon() {
      if (selectedPolygon.current !== null) {
        for (var i = 0; i < polygons.current.length; i++) {
          if (polygons.current[i] === selectedPolygon.current) {
            polygons.current.splice(i, 1);
            setPolygonSelected(false);
            return selectedPolygon.current.setMap(null);
          }
        }
      }
    }

    function saveCurrentDrawing() {
      deselect();
      var areas = [];
      polygons.current.forEach(function (polygon) {
        var p = polygon.getPath();
        if (typeof p === 'undefined') return;
        areas.push(p.getArray().map(function (area) {
          return [area.lng(), area.lat()];
        }));
      });

      var feature = function feature(coordinates) {
        return {
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'Polygon',
            coordinates: [coordinates]
          }
        };
      };

      var data = {
        type: 'FeatureCollection',
        features: areas.map(feature)
      };
      onSave(data);
    }

    var Action = function Action(_ref2) {
      var children = _ref2.children,
          rest = _objectWithoutPropertiesLoose(_ref2, ["children"]);

      return /*#__PURE__*/React__default.createElement("button", _extends({
        style: {
          border: 0,
          padding: 15,
          fontWeight: 'bold',
          cursor: 'pointer'
        }
      }, rest), children);
    };

    return /*#__PURE__*/React__default.createElement("div", {
      style: {
        position: 'relative',
        height: '100%',
        width: '100%'
      }
    }, /*#__PURE__*/React__default.createElement("div", {
      style: {
        height: '100%',
        width: '100%'
      },
      ref: mapRef
    }), editable && /*#__PURE__*/React__default.createElement("span", {
      style: {
        position: 'absolute',
        bottom: 20,
        right: 5,
        zIndex: 900,
        boxShadow: '0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)'
      }
    }, activeDrawing && activeDrawing.length > 0 && /*#__PURE__*/React__default.createElement(Action, {
      onClick: removeLastPoint
    }, "undo"), polygonSelected && /*#__PURE__*/React__default.createElement(Action, {
      onClick: removeSelectedPolygon
    }, "remove"), /*#__PURE__*/React__default.createElement(Action, {
      onClick: startEditing
    }, "+"), /*#__PURE__*/React__default.createElement(Action, {
      onClick: saveCurrentDrawing
    }, "save")), map && children({
      map: map
    }));
  }

  return ReactGeoJSON;

})));
